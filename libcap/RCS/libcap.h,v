head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	98.06.08.00.15.28;	author morgan;	state Exp;
branches;
next	1.4;

1.4
date	98.06.07.15.58.23;	author morgan;	state Exp;
branches;
next	1.3;

1.3
date	98.05.24.22.54.09;	author morgan;	state Exp;
branches;
next	1.2;

1.2
date	97.04.28.00.57.11;	author morgan;	state Exp;
branches;
next	1.1;

1.1
date	97.04.21.04.32.52;	author morgan;	state Exp;
branches;
next	;


desc
@first take
@


1.5
log
@accommodate alpha (glibc?)
@
text
@/*
 * $Id: libcap.h,v 1.4 1998/06/07 15:58:23 morgan Exp morgan $
 *
 * Copyright (c) 1997 Andrew G Morgan <morgan@@linux.kernel.org>
 *
 * See end of file for Log.
 *
 * This file contains internal definitions for the various functions in
 * this small capability library.
 */

#ifndef LIBCAP_H
#define LIBCAP_H

#include <sys/types.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/capability.h>

/* include the names for the caps and a definition of __CAP_BITS */
#include "cap_names.h"

/*
 * This is a pointer to a struct containing three consecutive
 * capability sets in the order of the cap_flag_t type: the are
 * effective,inheritable and permitted.  This is the type that the
 * user-space routines think of as 'internal' capabilities - this is
 * the type that is passed to the kernel with the system calls related
 * to processes.
 */

#define CAP_T_MAGIC 0xCA90D0
struct _cap_struct {
    int magic;
    struct __user_cap_header_struct head;
    struct __user_cap_data_struct set;
};

/*
 * Do we match the local kernel?
 */

#if !defined(_LINUX_CAPABILITY_VERSION) || \
            (_LINUX_CAPABILITY_VERSION != 0x19980330)

# error "Kernel <linux/capability.h> does not match library"
# error "file "libcap.h" --> fix and recompile libcap"

#endif

/*
 * kernel API cap set abstraction
 */

#define NUMBER_OF_CAP_SETS      3   /* effective, inheritable, permitted */
#define CAP_SET_SIZE (sizeof(struct __user_cap_data_struct)/NUMBER_OF_CAP_SETS)
#define __CAP_BLKS   (CAP_SET_SIZE/sizeof(__u32))
typedef struct {
    __u32 _blk[__CAP_BLKS];
} __cap_s;
#define raise_cap(x)   _blk[(x)>>5] |= (1<<((x)&31))
#define lower_cap(x)   _blk[(x)>>5] |= (1<<((x)&31))
#define isset_cap(y,x) ((y)->_blk[(x)>>5] & (1<<((x)&31)))

/*
 * Private definitions for internal use by the library.
 */

#define good_cap_t(c)      ((c) && (c)->magic == CAP_T_MAGIC)

/*
 * library debugging
 */
#ifdef DEBUG

#include <stdio.h>
# define _cap_debug(f, x...)  { \
    fprintf(stderr, __FUNCTION__ "(" __FILE__ ":%d): ", __LINE__); \
    fprintf(stderr, f, ## x); \
    fprintf(stderr, "\n"); \
}
# define _cap_debugcap(s, c) \
    fprintf(stderr, __FUNCTION__ "(" __FILE__ ":%d): " s \
       "%08x\n", __LINE__, c)

#else /* !DEBUG */

# define _cap_debug(f, x...)
# define _cap_debugcap(s, c)

#endif /* DEBUG */

/*
 * These are semi-public prototypes, they will only be defined in
 * <sys/capability.h> if _POSIX_SOURCE is not #define'd, so we
 * place them here too.
 */

extern int capset(cap_user_header_t header, cap_user_data_t data);
extern int capget(cap_user_header_t header, const cap_user_data_t data);
extern int capgetp(pid_t pid, cap_t cap_d);
extern int capsetp(pid_t pid, cap_t cap_d);

#endif /* LIBCAP_H */

/*
 * $Log: libcap.h,v $
 * Revision 1.4  1998/06/07 15:58:23  morgan
 * accommodate real kernel header files :*)
 *
 * Revision 1.3  1998/05/24 22:54:09  morgan
 * updated for 2.1.104
 *
 * Revision 1.2  1997/04/28 00:57:11  morgan
 * zefram's replacement file with a number of bug fixes from AGM
 *
 * Revision 1.1  1997/04/21 04:32:52  morgan
 * Initial revision
 *
 */
@


1.4
log
@accommodate real kernel header files :*)
@
text
@d2 1
a2 1
 * $Id: libcap.h,v 1.3 1998/05/24 22:54:09 morgan Exp morgan $
d15 1
d110 3
@


1.3
log
@updated for 2.1.104
@
text
@d2 1
a2 1
 * $Id: libcap.h,v 1.2 1997/04/28 00:57:11 morgan Exp morgan $
d36 2
a37 2
    struct _user_cap_header_struct head;
    struct _user_cap_data_struct set;
d57 1
a57 1
#define CAP_SET_SIZE  (sizeof(struct _user_cap_data_struct)/NUMBER_OF_CAP_SETS)
d109 3
@


1.2
log
@zefram's replacement file with a number of bug fixes from AGM
@
text
@d2 1
a2 1
 * $Id: libcap.h,v 1.1 1997/04/21 04:32:52 morgan Exp morgan $
d4 1
a4 1
 * Copyright (c) 1997 Andrew G Morgan <morgan@@parc.power.net>
d21 3
d36 2
a37 1
    struct __cap_s set[3];
d45 1
a45 1
            (_LINUX_CAPABILITY_VERSION != 0x19970420)
d53 14
d85 1
a85 2
       "%08x %08x %08x %08x\n", __LINE__, \
       (c)->_blk[0], (c)->_blk[1], (c)->_blk[2], (c)->_blk[3])
d100 4
a103 10
int _setproccap(size_t, __cap_s const *,__cap_s const *, __cap_s const *);
int _getproccap(size_t, __cap_s *,__cap_s *, __cap_s *);
int _setfilecap(char const *, size_t, __cap_s const *,
		__cap_s const *, __cap_s const *);
int _getfilecap(char const *, size_t, __cap_s *, __cap_s *, __cap_s *);
int _fsetfilecap(int, size_t, __cap_s const *,
		__cap_s const *, __cap_s const *);
int _fgetfilecap(int, size_t, __cap_s *, __cap_s *, __cap_s *);

extern char const *_cap_names[__CAP_BITS];
d109 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d19 1
a19 2

#include <linux/capability.h>
d22 1
a22 1
 * This is a pointer to an struct containing three consecutive
a47 8
#include <sys/capability.h>

/*
 * System calls
 */

#include <linux/unistd.h>

d63 1
a63 1
    fprintf(stderr, "\n");
d65 4
d73 1
d77 5
a81 2
/* These are semi-public prototypes -- perhaps they should be moved to
   <sys/capability.h> ? */
d84 1
a84 1
int _getproccap(size_t, __cap_s const *,__cap_s const *, __cap_s const *);
d87 1
a87 2
int _getfilecap(char const *, size_t, __cap_s const *,
		__cap_s const *, __cap_s const *);
d90 3
a92 2
int _fgetfilecap(int, size_t, __cap_s const *,
		__cap_s const *, __cap_s const *);
d97 4
a100 1
 * $Log$
@
