head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	98.05.24.22.54.09;	author morgan;	state Exp;
branches;
next	1.4;

1.4
date	97.05.14.05.17.13;	author morgan;	state Exp;
branches;
next	1.3;

1.3
date	97.05.04.05.35.46;	author morgan;	state Exp;
branches;
next	1.2;

1.2
date	97.04.28.00.57.11;	author morgan;	state Exp;
branches;
next	1.1;

1.1
date	97.04.21.04.32.52;	author morgan;	state Exp;
branches;
next	;


desc
@first take
@


1.5
log
@updated for 2.1.104
@
text
@/*
 * $Id: cap_proc.c,v 1.4 1997/05/14 05:17:13 morgan Exp morgan $
 *
 * Copyright (c) 1997-8 Andrew G Morgan <morgan@@linux.kernel.org>
 *
 * See end of file for Log.
 *
 * This file deals with setting capabilities on processes.
 */

#include "libcap.h"

cap_t cap_get_proc(void)
{
    cap_t result;

    /* allocate a new capability set */
    result = cap_init();
    if (result) {
	_cap_debug("getting current process' capabilities");

	/* fill the capability sets via a system call */
	if (capget(&result->head, &result->set)) {
	    cap_free(&result);
	}
    }

    return result;
}

int cap_set_proc(cap_t cap_d)
{
    if (!good_cap_t(cap_d)) {
	errno = EINVAL;
	return -1;
    }

    _cap_debug("setting process capabilities");
    return capset(&cap_d->head, &cap_d->set);
}

/* the following two functions are not required by POSIX */

/* read the caps on a specific process */

int capgetp(pid_t pid, cap_t cap_d)
{
    int error;

    if (!good_cap_t(cap_d)) {
	errno = EINVAL;
	return -1;
    }

    _cap_debug("getting process capabilities for proc %d", pid);

    cap_d->head.pid = pid;
    error = capget(&cap_d->head, &cap_d->set);
    cap_d->head.pid = 0;

    return error;
}

/* set the caps on a specific process/pg etc.. */

int capsetp(pid_t pid, cap_t cap_d)
{
    int error;

    if (!good_cap_t(cap_d)) {
	errno = EINVAL;
	return -1;
    }

    _cap_debug("setting process capabilities for proc %d", pid);
    cap_d->head.pid = pid;
    error = capset(&cap_d->head, &cap_d->set);
    cap_d->head.pid = 0;

    return error;
}

/*
 * $Log: cap_proc.c,v $
 * Revision 1.4  1997/05/14 05:17:13  morgan
 * bug-fix from zefram (errno no set on success)
 *
 * Revision 1.3  1997/05/04 05:35:46  morgan
 * fixed errno setting. syscalls do this part
 *
 * Revision 1.2  1997/04/28 00:57:11  morgan
 * fixes and zefram's patches
 *
 * Revision 1.1  1997/04/21 04:32:52  morgan
 * Initial revision
 *
 */
@


1.4
log
@bug-fix from zefram (errno no set on success)
@
text
@d2 1
a2 1
 * $Id: cap_proc.c,v 1.3 1997/05/04 05:35:46 morgan Exp morgan $
d4 1
a4 1
 * Copyright (c) 1997 Andrew G Morgan <morgan@@parc.power.net>
d23 1
a23 4
	if (_getproccap(sizeof(struct __cap_s),
			&result->set[CAP_INHERITABLE],
			&result->set[CAP_PERMITTED],
			&result->set[CAP_EFFECTIVE] ))
d25 1
d39 42
a80 4
    return _setproccap(sizeof(struct __cap_s),
			  &cap_d->set[CAP_INHERITABLE],
			  &cap_d->set[CAP_PERMITTED],
			  &cap_d->set[CAP_EFFECTIVE] );
d85 3
@


1.3
log
@fixed errno setting. syscalls do this part
@
text
@d2 1
a2 1
 * $Id: cap_proc.c,v 1.2 1997/04/28 00:57:11 morgan Exp morgan $
d35 1
a35 11
    if (good_cap_t(cap_d)) {
	_cap_debug("setting current process' capabilities");

	/* fill the capability sets via a system call */
	if (_setproccap(sizeof(struct __cap_s),
			&cap_d->set[CAP_INHERITABLE],
			&cap_d->set[CAP_PERMITTED],
			&cap_d->set[CAP_EFFECTIVE] )) {
	    _cap_debug("failed: %s", strerror(errno));
	}
    } else
d37 2
d40 5
a44 1
    return (errno ? -1:0);
d49 3
@


1.2
log
@fixes and zefram's patches
@
text
@d2 1
a2 1
 * $Id: cap_proc.c,v 1.1 1997/04/21 04:32:52 morgan Exp morgan $
d23 4
a26 6
	errno = -_getproccap(sizeof(struct __cap_s),
			     &result->set[CAP_INHERITABLE],
			     &result->set[CAP_PERMITTED],
			     &result->set[CAP_EFFECTIVE] );

	if (errno)
d39 6
a44 4
	errno = -_setproccap(sizeof(struct __cap_s),
			     &cap_d->set[CAP_INHERITABLE],
			     &cap_d->set[CAP_PERMITTED],
			     &cap_d->set[CAP_EFFECTIVE] );
d53 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d21 1
d27 3
d39 1
d52 4
a55 1
 * $Log$
@
