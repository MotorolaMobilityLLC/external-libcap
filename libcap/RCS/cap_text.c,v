head	1.4;
access;
symbols;
locks; strict;
comment	@ * @;


1.4
date	98.05.24.22.54.09;	author morgan;	state Exp;
branches;
next	1.3;

1.3
date	97.05.04.05.37.00;	author morgan;	state Exp;
branches;
next	1.2;

1.2
date	97.04.28.00.57.11;	author morgan;	state Exp;
branches;
next	1.1;

1.1
date	97.04.21.04.32.52;	author morgan;	state Exp;
branches;
next	;


desc
@first take
@


1.4
log
@updated for 2.1.104
@
text
@/*
 * $Id: cap_text.c,v 1.3 1997/05/04 05:37:00 morgan Exp morgan $
 *
 * Copyright (c) 1997-8 Andrew G Morgan <morgan@@linux.kernel.org>
 * Copyright (c) 1997 Andrew Main <zefram@@dcs.warwick.ac.uk>
 *
 * See end of file for Log.
 *
 * This file deals with exchanging internal and textual
 * representations of capability sets.
 */

#define LIBCAP_PLEASE_INCLUDE_ARRAY
#include "libcap.h"

#include <ctype.h>
#include <stdio.h>

char *strdup(const char *s);

/* Maximum output text length (16 per cap) */
#define CAP_TEXT_SIZE    (16*__CAP_BITS)

#define LIBCAP_EFF   01
#define LIBCAP_INH   02
#define LIBCAP_PER   04

/*
 * Parse a textual representation of capabilities, returning an internal
 * representation.
 */

#define setbits(A,B) _setbits((__cap_s *)A, (__cap_s *)B)
static void _setbits(__cap_s *a, __cap_s *b)
{
    int n;
    for (n = __CAP_BLKS; n--; )
	a->_blk[n] |= b->_blk[n];
}

#define clrbits(A,B) _clrbits((__cap_s *)A, (__cap_s *)B)
static void _clrbits(__cap_s *a, __cap_s *b)
{
    int n;
    for (n = __CAP_BLKS; n--; )
	a->_blk[n] &= ~b->_blk[n];
}

static char const *namcmp(char const *str, char const *nam)
{
    while (*nam && tolower((unsigned char)*str) == *nam) {
	str++;
	nam++;
    }
    if (*nam || isalnum((unsigned char)*str) || *str == '_')
	return NULL;
    return str;
}

static int lookupname(char const **strp)
{
    char const *str = *strp;
    if (isdigit(*str)) {
	unsigned long n = strtoul(str, (char **)&str, 0);
	if (n >= __CAP_BITS)
	    return -1;
	*strp = str;
	return n;
    } else {
	char const *s;
	int n;
	for (n = __CAP_BITS; n--; )
	    if (_cap_names[n] && (s = namcmp(str, _cap_names[n]))) {
		*strp = s;
		return n;
	    }
	return -1;
    }
}

cap_t cap_from_text(const char *str)
{
    cap_t res;
    __cap_s allones;
    int n;

    if (str == NULL) {
	_cap_debug("bad argument");
	errno = EINVAL;
	return NULL;
    }

    if (!(res = cap_init()))
	return NULL;
    for (n = __CAP_BLKS; n--; )
	allones._blk[n] = -1;
    _cap_debug("%s", str);

    for (;;) {
	char op;
	int flags = 0, listed=0;
	__cap_s list = {{0}};

	/* skip leading spaces */
	while (isspace((unsigned char)*str))
	    str++;
	if (!*str) {
	    _cap_debugcap("e = ", &res->set.effective);
	    _cap_debugcap("i = ", &res->set.inheritable);
	    _cap_debugcap("p = ", &res->set.permitted);
	    return res;
	}

	/* identify caps specified by this clause */
	if (isalnum((unsigned char)*str) || *str == '_') {
	    for (;;) {
		if (namcmp(str, "all")) {
		    str += 3;
		    list = allones;
		} else {
		    n = lookupname(&str);
		    if (n == -1)
			goto bad;
		    list.raise_cap(n);
		}
		if (*str != ',')
		    break;
		if (!isalnum((unsigned char)*++str) && *str != '_')
		    goto bad;
	    }
	    listed = 1;
	} else if (*str == '+' || *str == '-')
	    goto bad;                    /* require a list of capabilities */
	else
	    list = allones;

	/* identify first operation on list of capabilities */
	op = *str++;
	if (op == '=' && (*str == '+' || *str == '-')) {
	    if (!listed)
		goto bad;
	    op = (*str++ == '+' ? 'P':'M'); /* skip '=' and take next op */
	} else if (op != '+' && op != '-' && op != '=')
	    goto bad;

	/* cycle through list of actions */
	do {
	    _cap_debug("next char = `%c'", *str);
	    if (*str && !isspace(*str)) {
		switch (*str++) {    /* Effective, Inheritable, Permitted */
		case 'e':
		    flags |= LIBCAP_EFF;
		    break;
		case 'i':
		    flags |= LIBCAP_INH;
		    break;
		case 'p':
		    flags |= LIBCAP_PER;
		    break;
		default:
		    goto bad;
		}
	    } else if (op != '=') {
		_cap_debug("only '=' can be followed by space");
		goto bad;
	    }

	    _cap_debug("how to read?");
	    switch (op) {               /* how do we interpret the caps? */
	    case '=':
	    case 'P':                                              /* =+ */
	    case 'M':                                              /* =- */
		clrbits(&res->set.effective,   &list);
		clrbits(&res->set.inheritable, &list);
		clrbits(&res->set.permitted,   &list);
		/* fall through */
		if (op == 'M')
		    goto minus;
	    case '+':
		if (flags & LIBCAP_EFF)
		    setbits(&res->set.effective,   &list);
		if (flags & LIBCAP_INH)
		    setbits(&res->set.inheritable, &list);
		if (flags & LIBCAP_PER)
		    setbits(&res->set.permitted,   &list);
		break;
	    case '-':
	    minus:
	        if (flags & LIBCAP_EFF)
		    clrbits(&res->set.effective,   &list);
		if (flags & LIBCAP_INH)
		    clrbits(&res->set.inheritable, &list);
		if (flags & LIBCAP_PER)
		    clrbits(&res->set.permitted,   &list);
		break;
	    }

	    /* new directive? */
	    if (*str == '+' || *str == '-') {
		if (!listed) {
		    _cap_debug("for + & - must list capabilities");
		    goto bad;
		}
		flags = 0;                       /* reset the flags */
		op = *str++;
		if (!isalpha(*str))
		    goto bad;
	    }
	} while (*str && !isspace(*str));
	_cap_debug("next clause");
    }

bad:
    cap_free(&res);
    errno = EINVAL;
    return NULL;
}

/*
 * Convert an internal representation to a textual one. The textual
 * representation is stored in static memory. It will be overwritten
 * on the next occasion that this function is called.
 */

static int getstateflags(cap_t caps, int capno)
{
    int f = 0;

    if (isset_cap((__cap_s *)(&caps->set.effective),capno))
	f |= LIBCAP_EFF;
    if (isset_cap((__cap_s *)(&caps->set.inheritable),capno))
	f |= LIBCAP_INH;
    if (isset_cap((__cap_s *)(&caps->set.permitted),capno))
	f |= LIBCAP_PER;

    return f;
}

#define CAP_TEXT_BUFFER_ZONE 100

char *cap_to_text(cap_t caps, ssize_t *length_p)
{
    static char buf[CAP_TEXT_SIZE+CAP_TEXT_BUFFER_ZONE];
    char *p;
    int histo[8] = {0};
    int m, n, t;

    /* Check arguments */
    if (!good_cap_t(caps) || length_p == NULL) {
	errno = EINVAL;
	return NULL;
    }

    _cap_debugcap("e = ", &caps->set.effective);
    _cap_debugcap("i = ", &caps->set.inheritable);
    _cap_debugcap("p = ", &caps->set.permitted);

    for (n = __CAP_BITS; n--; )
	histo[getstateflags(caps, n)]++;

    for (m=t=7; t--; )
	if (histo[t] > histo[m])
	    m = t;

    /* blank is not a valid capability set */
    p = sprintf(buf, "=%s%s%s",
		(m & LIBCAP_EFF) ? "e" : "",
		(m & LIBCAP_INH) ? "i" : "",
		(m & LIBCAP_PER) ? "p" : "" ) + buf;

    for (t = 8; t--; )
	if (t != m && histo[t]) {
	    *p++ = ' ';
	    for (n = 0; n != __CAP_BITS; n++)
		if (getstateflags(caps, n) == t) {
		    if (_cap_names[n])
			p += sprintf(p, "%s,", _cap_names[n]);
		    else
			p += sprintf(p, "%d,", n);
		    if (p - buf > CAP_TEXT_SIZE) {
			errno = ERANGE;
			return NULL;
		    }
		}
	    p--;
	    n = t & ~m;
	    if (n)
		p += sprintf(p, "+%s%s%s",
			     (n & LIBCAP_EFF) ? "e" : "",
			     (n & LIBCAP_INH) ? "i" : "",
			     (n & LIBCAP_PER) ? "p" : "");
	    n = ~t & m;
	    if (n)
		p += sprintf(p, "-%s%s%s",
			     (n & LIBCAP_EFF) ? "e" : "",
			     (n & LIBCAP_INH) ? "i" : "",
			     (n & LIBCAP_PER) ? "p" : "");
	    if (p - buf > CAP_TEXT_SIZE) {
		errno = ERANGE;
		return NULL;
	    }
	}

    _cap_debug("%s", buf);
    *length_p = p - buf;
    return (strdup(buf));
}

/*
 * $Log: cap_text.c,v $
 * Revision 1.3  1997/05/04 05:37:00  morgan
 * case sensitvity to capability flags
 *
 * Revision 1.2  1997/04/28 00:57:11  morgan
 * zefram's replacement file with a number of bug fixes from AGM
 *
 * Revision 1.1  1997/04/21 04:32:52  morgan
 * Initial revision
 *
 */
@


1.3
log
@case sensitvity to capability flags
@
text
@d2 1
a2 1
 * $Id: cap_text.c,v 1.2 1997/04/28 00:57:11 morgan Exp morgan $
d4 1
a4 1
 * Copyright (c) 1997 Andrew G Morgan <morgan@@parc.power.net>
d13 1
d19 2
d33 2
a34 1
static void setbits(__cap_s *a, __cap_s *b)
d41 2
a42 1
static void clrbits(__cap_s *a, __cap_s *b)
d108 3
a110 3
	    _cap_debugcap("e = ", &res->set[CAP_EFFECTIVE]);
	    _cap_debugcap("i = ", &res->set[CAP_INHERITABLE]);
	    _cap_debugcap("p = ", &res->set[CAP_PERMITTED]);
d124 1
a124 1
		    list._cap_raise(n);
d173 3
a175 3
		clrbits(&res->set[CAP_EFFECTIVE],   &list);
		clrbits(&res->set[CAP_INHERITABLE], &list);
		clrbits(&res->set[CAP_PERMITTED],   &list);
d181 1
a181 1
		    setbits(&res->set[CAP_EFFECTIVE],   &list);
d183 1
a183 1
		    setbits(&res->set[CAP_INHERITABLE], &list);
d185 1
a185 1
		    setbits(&res->set[CAP_PERMITTED],   &list);
d190 1
a190 1
		    clrbits(&res->set[CAP_EFFECTIVE],   &list);
d192 1
a192 1
		    clrbits(&res->set[CAP_INHERITABLE], &list);
d194 1
a194 1
		    clrbits(&res->set[CAP_PERMITTED],   &list);
d229 1
a229 1
    if (caps->set[CAP_EFFECTIVE]._cap_raised(capno))
d231 1
a231 1
    if (caps->set[CAP_INHERITABLE]._cap_raised(capno))
d233 1
a233 1
    if (caps->set[CAP_PERMITTED]._cap_raised(capno))
d254 3
a256 3
    _cap_debugcap("e = ", &caps->set[CAP_EFFECTIVE]);
    _cap_debugcap("i = ", &caps->set[CAP_INHERITABLE]);
    _cap_debugcap("p = ", &caps->set[CAP_PERMITTED]);
d306 1
a306 1
    return buf;
d311 3
@


1.2
log
@zefram's replacement file with a number of bug fixes from AGM
@
text
@d2 1
a2 1
 * $Id: cap_text.c,v 1.1 1997/04/21 04:32:52 morgan Exp morgan $
a146 1
		case 'E':
a149 1
		case 'I':
a152 1
		case 'P':
d306 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d5 1
d16 1
d18 2
a19 64
/*
 * Some static data:
 */

/* A place to store the capability names */
static const char * cap_text[__CAP_BITS] = {

/*
 * POSIX capabilities
 */

/* CAP_CHOWN (0) */		"cap_chown",
/* CAP_DAC_OVERRIDE */		"cap_dac_override",
/* CAP_DAC_READ_SEARCH */	"cap_dac_read_search",
/* CAP_FOWNER */		"cap_fowner",
/* CAP_FSETID */		"cap_fsetid",
/* CAP_KILL (5) */ 		"cap_kill",
/* CAP_LINK_DIR */		"cap_link_dir",
/* CAP_SETFCAP */		"cap_setfcap",
/* CAP_SETGID */		"cap_setgid",
/* CAP_SETUID */		"cap_setuid",
/* CAP_SIGMASK (10) */		"cap_sigmask",

/* CAP_MAC_DOWNGRADE (11) */	"cap_mac_downgrade",
/* CAP_MAC_READ */		"cap_mac_read",
/* CAP_MAC_RELABEL_SUB */	"cap_mac_relabel_sub",
/* CAP_MAC_UPGRADE */		"cap_mac_upgrade",
/* CAP_MAC_WRITE */		"cap_mac_write",

/* CAP_INF_NOFLOAT_OBJ (16) */	"cap_inf_nofloat_obj",
/* CAP_INF_NOFLOAT_SUB */	"cap_inf_nofloat_lab",
/* CAP_INF_RELABEL_OBJ */	"cap_inf_relabel_obj",
/* CAP_INF_RELABEL_SUB */	"cap_inf_relabel_sub",

/* CAP_AUDIT_CONTROL (20) */	"cap_audit_control",
/* CAP_AUDIT_WRITE */		"cap_audit_write",

/* (22) reserved for POSIX */   NULL,
/* (23) reserved for POSIX */   NULL,
/* (24) reserved for POSIX */   NULL,
/* (25) reserved for POSIX */   NULL,
/* (26) reserved for POSIX */   NULL,
/* (27) reserved for POSIX */   NULL,
/* (28) reserved for POSIX */   NULL,
/* (29) reserved for POSIX */   NULL,
/* (30) reserved for POSIX */   NULL,
/* (31) reserved for POSIX */   NULL,

/*
 * Linux-specific capabilities
 */

/* CAP_LINUX_IMMUTABLE (32) */	"cap_linux_immutable",
/* CAP_LINUX_KERNELD */		"cap_linux_kerneld",
/* CAP_LINUX_INSMOD */		"cap_linux_insmod",
/* CAP_LINUX_RMMOD */		"cap_linux_rmmod",
/* CAP_LINUX_RAWIO */		"cap_linux_rawio",
/* CAP_LINUX_ATTENTION */	"cap_linux_attention",
/* CAP_LINUX_RANDOM */		"cap_linux_random",

/*
 * Others.. A number of others have been defined; they do not belong
 * to Linux or POSIX. [Subject to change].
 */
d21 3
a23 24
/* CAP_NET_BIND_SERVICE (39) */	"cap_net_bind_service",
/* CAP_NET_BROADCAST */		"cap_net_broadcast",
/* CAP_NET_DEBUG */		"cap_net_debug",
/* CAP_NET_FIREWALL */		"cap_net_firewall",
/* CAP_NET_IFCONFIG */		"cap_net_ifconfig",
/* CAP_NET_PACKET */		"cap_net_packet",
/* CAP_NET_RAW (45) */		"cap_net_raw",
/* CAP_NET_ROUTE */		"cap_net_route",
/* CAP_NET_SETID */		"cap_net_setid",
/* CAP_IPC_LOCK */		"cap_ipc_lock",
/* CAP_IPC_OWNER */		"cap_ipc_owner",
/* CAP_SYS_CHROOT (50) */	"cap_sys_chroot",
/* CAP_SYS_PTRACE */		"cap_sys_ptrace",
/* CAP_SYS_ACCOUNT */		"cap_sys_account",
/* CAP_SYS_ADMIN */		"cap_sys_admin",
/* CAP_SYS_BOOT */		"cap_sys_boot",
/* CAP_SYS_DEVICES (55) */	"cap_sys_devices",
/* CAP_SYS_NICE */		"cap_sys_nice",
/* CAP_SYS_RESOURCE */		"cap_sys_resource",
/* CAP_SYS_TIME */		"cap_sys_time",
/* CAP_SYS_TTY_CONFIG */	"cap_sys_tty_config",
/* CAP_SYS_QUOTA (60) */	"cap_sys_quota",

};
d26 2
a27 1
 * static parsing routines
d30 1
a30 6
/*
 * Caseless string comparison
 */

/* caseless string comparison: POSIX does not define this.. */
static int _strCMP(const char *s, const char *t)
d32 3
a34 8
    int cf;

    do {
	cf = tolower(*s) - tolower(*t);
	++t;
    } while (!cf && *s++);

    return cf;
d37 1
a37 21
/*
 *  Locate character (c) in an array of characters (array)
 */

static int _cap_inarray(char c, const char * array)
{
    int i;

    for (i=0; *array; ++array, ++i) {
	if (c == *array)
	    return i;
    }

    return -1;
}

/*
 * Locate a token (tok) in an capability array
 */

static int _cap_find_token(const char * const tok)
d39 3
a41 9
    int i;

    for (i=0; i<__CAP_BITS; ++i) {
	if (cap_text[i] && !_strCMP(cap_text[i], tok)) {
	    _cap_debug("located [%s]=%d", cap_text[i], i);
	    return i;
	}
    }
    return -1;
d44 1
a44 5
/*
 * This function copies the next clause (returning NULL at end)
 */

static const char *_cap_get_clause(const char *from, char **to)
d46 3
a48 6
    const char *begin;

    /* forget last value */
    if (*to) {
	free(*to);
	*to = NULL;
d50 1
a50 3

    /* verify that we have something to search */
    if (from == NULL) {
d52 1
a52 26
    }

    /* skip leading spaces */
    for (; *from && isspace(*from); ++from);

    /* do we have a clause? */
    if (*from) {
	int length;

	/* Skip to next space */
	for (begin = from; *from && !isspace(*from); ++from);

	length = from - begin;
	*to = malloc(1 + length);
	if (*to == NULL) {
	    _cap_debug("out of memory");
	    errno = ENOMEM;
	    return NULL;
	}

	/* copy clause */
	memcpy(*to, begin, length);
	(*to)[length] = '\0';
    }

    return (*from ? from:NULL);
d55 1
a55 8
/*
 * Read comma separated capabilities and set them in the argument capability
 * set.
 */

static const char * const op_list = "=+-";

static char *_cap_parse_caps(char *temp, __cap_s *caps)
d57 7
a63 21
    char *ops, saved;
    const char *tok;

    if (temp == NULL) {
	_cap_debug("no capabilities provided");
	return NULL;
    }

    /* find first non-capability char (=+-) and save for later writeback */
    for (ops=temp; (saved=*ops) && _cap_inarray(saved, op_list) < 0; ++ops);
    *ops = '\0';

    /* loop through tokens looking up each capability and raising it in caps */
    if (!_strCMP("all", temp)) {
	int i;

	/* A little slow but this way we only raise defined capabilities */
	for (i=0; i<__CAP_BITS; ++i) {
	    if (cap_text[i])
		caps->_cap_raise(i);
	}
d65 6
a70 11
	/* break string into tokens */
	while ((tok = strtok(temp, ","))) {
	    int cap;

	    temp = NULL;

	    cap = _cap_find_token(tok);
	    if (cap == -1) {
		_cap_debug("tok=[%s] is not known - ignoring it", tok);
	    } else {
		caps->_cap_raise(cap);
d72 1
a72 22
	}
    }

    /* writeback first operator char */
    *ops = saved;

    /* return operator list */
    return ops;
}

/*
 * read the operator list and set the internal flags accordingly
 */

static struct __cap_s cap_purge(const struct __cap_s *a,
				const struct __cap_s *b)
{
    struct __cap_s result;
    register i;

    for (i=0; i<__CAP_BLKS; ++i) {
	result._blk[i] = a->_blk[i] & ~b->_blk[i];
a73 1
    return result;
d76 1
a76 2
static struct __cap_s cap_union(const struct __cap_s *a,
				const struct __cap_s *b)
d78 3
a80 2
    struct __cap_s result;
    register i;
d82 4
a85 2
    for (i=0; i<__CAP_BLKS; ++i) {
	result._blk[i] = a->_blk[i] | b->_blk[i];
a86 2
    return result;
}
d88 20
a107 3
#define _LIBCAP_EQ   01
#define _LIBCAP_PL   02
#define _LIBCAP_MI   03
d109 16
a124 38
static void _cap_parse_ops(char *temp, __cap_s *caps, cap_t cap_d)
{
    unsigned int state=0;
    char c;

    while ((c = *temp++)) {
	int op;

	/* Is this an operator? */
	if ((op = _cap_inarray(c, op_list)) >= 0) {
	    c = '\0';
	    state = 1+op;
	    if (*temp && _cap_inarray(*temp, op_list) < 0)
		continue;
	    /* Fall through for immediate action */
	}
	switch (c) {
	case '\0':
	    switch ((state & 03)) {
	    case _LIBCAP_EQ:
		memset(&(cap_d->set), 0, 3*sizeof(__cap_s));
		break;
	    case _LIBCAP_PL:
		cap_d->set[CAP_EFFECTIVE]
		    = cap_union(&cap_d->set[CAP_EFFECTIVE], caps);
		cap_d->set[CAP_INHERITABLE]
		    = cap_union(&cap_d->set[CAP_EFFECTIVE], caps);
		cap_d->set[CAP_PERMITTED]
		    = cap_union(&cap_d->set[CAP_EFFECTIVE], caps);
		break;
	    case _LIBCAP_MI:
		cap_d->set[CAP_EFFECTIVE]
		    = cap_purge(&cap_d->set[CAP_EFFECTIVE], caps);
		cap_d->set[CAP_INHERITABLE]
		    = cap_purge(&cap_d->set[CAP_EFFECTIVE], caps);
		cap_d->set[CAP_PERMITTED]
		    = cap_purge(&cap_d->set[CAP_EFFECTIVE], caps);
		break;
d126 38
a163 15
	    break;
	case 'e':
	case 'E':                                    /* set effective caps */
	    switch ((state & 03)) {
	    case _LIBCAP_EQ:
		memset(&(cap_d->set[CAP_EFFECTIVE]), 0, sizeof(__cap_s));
		break;
	    case _LIBCAP_PL:
		cap_d->set[CAP_EFFECTIVE]
		    = cap_union(&cap_d->set[CAP_EFFECTIVE], caps);
		break;
	    case _LIBCAP_MI:
		cap_d->set[CAP_EFFECTIVE]
		    = cap_purge(&cap_d->set[CAP_EFFECTIVE], caps);
		break;
d165 28
a192 14
	    break;
	case 'i':
	case 'I':
	    switch ((state & 03)) {
	    case _LIBCAP_EQ:
		memset(&(cap_d->set[CAP_INHERITABLE]), 0, sizeof(__cap_s));
		break;
	    case _LIBCAP_PL:
		cap_d->set[CAP_INHERITABLE]
		    = cap_union(&cap_d->set[CAP_INHERITABLE], caps);
		break;
	    case _LIBCAP_MI:
		cap_d->set[CAP_INHERITABLE]
		    = cap_purge(&cap_d->set[CAP_INHERITABLE], caps);
d195 11
a205 15
	    break;
	case 'p':
	case 'P':
	    switch ((state & 03)) {
	    case _LIBCAP_EQ:
		memset(&(cap_d->set[CAP_PERMITTED]), 0, sizeof(__cap_s));
		break;
	    case _LIBCAP_PL:
		cap_d->set[CAP_PERMITTED]
		    = cap_union(&cap_d->set[CAP_PERMITTED], caps);
		break;
	    case _LIBCAP_MI:
		cap_d->set[CAP_PERMITTED]
		    = cap_purge(&cap_d->set[CAP_PERMITTED], caps);
		break;
d207 2
a208 4
	    break;
	default:
	    _cap_debug("[%c] is ignored", c);
	}
d210 5
d218 3
a220 1
 * Convert a textual representation to a capability set.
d223 1
a223 1
cap_t cap_from_text(const char *verbose)
d225 1
a225 29
    char *clause=NULL;
    cap_t cap_d;

    cap_d = cap_init();
    if (cap_d == NULL) {
	_cap_debug("out of memory");
	errno = ENOMEM;
	return NULL;
    }

    /* Loop through clauses */
    while ((verbose = _cap_get_clause(verbose, &clause))) {
	struct __cap_s capabilities;
	char *temp = clause;

	/* reset local capability set */
	memset(&capabilities, 0, sizeof(capabilities));

	/* spin through capabilities listed in this clause */
	temp = _cap_parse_caps(temp, &capabilities);
	if (temp) {
	    /* spin through list of operators? */
	    _cap_parse_ops(temp, &capabilities, cap_d);
	}
    }

    /* return the capability set */
    return cap_d;
}
d227 6
a232 4
static int count_bits(struct __cap_s *cap)
{
    register int i,count=0;
    register __u32 block=0;
d234 1
a234 6
    for (i=0; i<__CAP_BLKS; ++i) {
	for (block = cap->_blk[i]; block; block >>= 1) {
	    count += (block&1);
	}
    }
    return count;
a236 10
/*
 * Convert an internal representation to a textual one. The textual
 * representation is stored in static memory. It will be overwritten
 * on the next occasion that this function is called.
 */

#define _LIBCAP_EFF   01
#define _LIBCAP_INH   02
#define _LIBCAP_PER   04

d239 1
a239 1
char *cap_to_text(cap_t cap_d, ssize_t *length_p)
a240 2
    int mone, moni, monp;
    unsigned int persist;
d242 3
a244 1
    int length, i;
d247 1
a247 1
    if (!good_cap_t(cap_d) || length_p == NULL) {
d252 30
a281 44
    mone = (count_bits(&cap_d->set[CAP_EFFECTIVE]) > 16) ? 1:0;
    moni = (count_bits(&cap_d->set[CAP_INHERITABLE]) > 16) ? 1:0;
    monp = (count_bits(&cap_d->set[CAP_PERMITTED]) > 16) ? 1:0;

    *length_p = 0;
    length = sprintf(buf, "all%se%si%sp\n",
		     mone ? "+":"-",
		     moni ? "+":"-",
		     monp ? "+":"-" );

    /* loop through clustering together all caps that are stored in
       the same selection of sets.. */
    for (persist=0, i=0; i<=__CAP_BITS; ++i) {
	unsigned int this=0;

	/* Which have this capability set? */
	if (i != __CAP_BITS) {
	    if ((!mone && cap_d->set[CAP_EFFECTIVE]._cap_raised(i))
		|| (mone && !cap_d->set[CAP_EFFECTIVE]._cap_raised(i)))
		this |= _LIBCAP_EFF;
	    if ((!moni && cap_d->set[CAP_INHERITABLE]._cap_raised(i))
		|| (moni && !cap_d->set[CAP_INHERITABLE]._cap_raised(i)))
		this |= _LIBCAP_INH;
	    if ((!monp && cap_d->set[CAP_PERMITTED]._cap_raised(i))
		|| (monp && !cap_d->set[CAP_PERMITTED]._cap_raised(i)))
		this |= _LIBCAP_PER;
	} else
	    this = ~0;

	/* should we include this capability? */
	if (this) {
	    if (persist && (i == __CAP_BITS || this != persist)) {
		/* write out actionlist for persistent caps */
		length += sprintf(length+buf, "%s%s%s\n"
				  , (persist & _LIBCAP_EFF) ?
				                     (mone?"-e":"+e"):""
				  , (persist & _LIBCAP_INH) ?
				                     (moni?"-i":"+i"):""
				  , (persist & _LIBCAP_PER) ?
				                     (monp?"-p":"+p"):""
		    );
		if (length > CAP_TEXT_SIZE) {
		    errno = ERANGE;
		    return NULL;
d283 14
a296 15
		persist=0;
	    }
	    if (i == __CAP_BITS) {
		/* All done */
		break;
	    }

	    if (cap_text[i]) {
		length += sprintf(length+buf, "%s%s", persist? ",":""
				  , cap_text[i]);
	    } else {
		_cap_debug("cap [%d] not defined but is set!?", i);
		length += sprintf(length+buf, "%s(%d)", persist?",":"", i);
	    }
	    if (length > CAP_TEXT_SIZE) {
a299 3

	    /* we may have a new persistent combination */
	    persist = this;
a300 3
    }

    /* return text */
d302 2
a303 1
    *length_p = strlen(buf);
d308 4
a311 1
 * $Log$
@
