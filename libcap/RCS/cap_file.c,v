head	1.5;
access;
symbols;
locks; strict;
comment	@ * @;


1.5
date	98.05.24.22.54.09;	author morgan;	state Exp;
branches;
next	1.4;

1.4
date	97.05.14.05.17.13;	author morgan;	state Exp;
branches;
next	1.3;

1.3
date	97.05.04.05.35.46;	author morgan;	state Exp;
branches;
next	1.2;

1.2
date	97.04.28.00.57.11;	author morgan;	state Exp;
branches;
next	1.1;

1.1
date	97.04.21.04.32.52;	author morgan;	state Exp;
branches;
next	;


desc
@first take
@


1.5
log
@updated for 2.1.104
@
text
@/*
 * $Id: cap_file.c,v 1.4 1997/05/14 05:17:13 morgan Exp morgan $
 *
 * Copyright (c) 1997 Andrew G Morgan <morgan@@linux.kernel.org>
 *
 * See end of file for Log.
 *
 * This file deals with setting capabilities on files.
 */

#include "libcap.h"

/*
 * Get the capabilities of an open file, as specified by its file
 * descriptor.
 */

cap_t cap_get_fd(int fildes)
{
    cap_t result;

    /* allocate a new capability set */
    result = cap_init();
    if (result) {
	_cap_debug("getting fildes capabilities");

	/* fill the capability sets via a system call */
	if (_fgetfilecap(fildes, sizeof(struct __cap_s),
			      &result->set[CAP_INHERITABLE],
			      &result->set[CAP_PERMITTED],
			      &result->set[CAP_EFFECTIVE] )) {
	    cap_free(&result);
	}
    }

    return result;
}

/*
 * Set the capabilities on a named file.
 */

cap_t cap_get_file(const char *filename)
{
    cap_t result;

    /* allocate a new capability set */
    result = cap_init();
    if (result) {
	_cap_debug("getting named file capabilities");

	/* fill the capability sets via a system call */
	if (_getfilecap(filename, sizeof(struct __cap_s),
			     &result->set[CAP_INHERITABLE],
			     &result->set[CAP_PERMITTED],
			     &result->set[CAP_EFFECTIVE] ))
	    cap_free(&result);
    }

    return result;
}

/*
 * Set the capabilities of an open file, as specified by its file
 * descriptor.
 */

int cap_set_fd(int fildes, cap_t cap_d)
{
    if (!good_cap_t(cap_d)) {
	errno = EINVAL;
	return -1;
    }

    _cap_debug("setting fildes capabilities");
    return _fsetfilecap(fildes, sizeof(struct __cap_s),
			  &cap_d->set[CAP_INHERITABLE],
			  &cap_d->set[CAP_PERMITTED],
			  &cap_d->set[CAP_EFFECTIVE] );
}

/*
 * Set the capabilities of a named file.
 */

int cap_set_file(const char *filename, cap_t cap_d)
{
    if (!good_cap_t(cap_d)) {
	errno = EINVAL;
	return -1;
    }

    _cap_debug("setting filename capabilities");
    return _setfilecap(filename, sizeof(struct __cap_s),
			  &cap_d->set[CAP_INHERITABLE],
			  &cap_d->set[CAP_PERMITTED],
			  &cap_d->set[CAP_EFFECTIVE] );
}

/*
 * $Log: cap_file.c,v $
 * Revision 1.4  1997/05/14 05:17:13  morgan
 * bug-fix from zefram (errno no set on success)
 *
 * Revision 1.3  1997/05/04 05:35:46  morgan
 * fixed errno setting. syscalls do this part
 *
 * Revision 1.2  1997/04/28 00:57:11  morgan
 * fixes and zefram's patches
 *
 * Revision 1.1  1997/04/21 04:32:52  morgan
 * Initial revision
 *
 */
@


1.4
log
@bug-fix from zefram (errno no set on success)
@
text
@d2 1
a2 1
 * $Id: cap_file.c,v 1.3 1997/05/04 05:35:46 morgan Exp morgan $
d4 1
a4 1
 * Copyright (c) 1997 Andrew G Morgan <morgan@@parc.power.net>
d102 3
@


1.3
log
@fixed errno setting. syscalls do this part
@
text
@d2 1
a2 1
 * $Id: cap_file.c,v 1.2 1997/04/28 00:57:11 morgan Exp morgan $
d70 1
a70 10
    if (good_cap_t(cap_d)) {
	_cap_debug("setting fildes capabilities");

	if (_fsetfilecap(fildes, sizeof(struct __cap_s),
			 &cap_d->set[CAP_INHERITABLE],
			 &cap_d->set[CAP_PERMITTED],
			 &cap_d->set[CAP_EFFECTIVE] )) {
	    _cap_debug("failed: %s", strerror(errno));
	}
    } else {
d72 1
d75 5
a79 1
    return (errno ? -1:0);
d88 1
a88 10
    if (good_cap_t(cap_d)) {
	_cap_debug("setting named file capabilities");

	if (_setfilecap(filename, sizeof(struct __cap_s),
			&cap_d->set[CAP_INHERITABLE],
			&cap_d->set[CAP_PERMITTED],
			&cap_d->set[CAP_EFFECTIVE] )) {
	    _cap_debug("failed: %s", strerror(errno));
	}
    } else {
d90 1
d93 5
a97 1
    return (errno ? -1:0);
d102 3
@


1.2
log
@fixes and zefram's patches
@
text
@d2 1
a2 1
 * $Id: cap_file.c,v 1.1 1997/04/21 04:32:52 morgan Exp morgan $
d28 1
a28 1
	errno = -_fgetfilecap(fildes, sizeof(struct __cap_s),
d31 1
a31 3
			      &result->set[CAP_EFFECTIVE] );

	if (errno)
d33 1
d53 1
a53 1
	errno = -_getfilecap(filename, sizeof(struct __cap_s),
d56 1
a56 3
			     &result->set[CAP_EFFECTIVE] );

	if (errno)
d73 6
a78 4
	errno = -_fsetfilecap(fildes, sizeof(struct __cap_s),
			      &cap_d->set[CAP_INHERITABLE],
			      &cap_d->set[CAP_PERMITTED],
			      &cap_d->set[CAP_EFFECTIVE] );
d95 6
a100 4
	errno = -_setfilecap(filename, sizeof(struct __cap_s),
			      &cap_d->set[CAP_INHERITABLE],
			      &cap_d->set[CAP_PERMITTED],
			      &cap_d->set[CAP_EFFECTIVE] );
d110 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * $Id$
d26 1
d32 3
d52 1
d58 3
d75 1
d95 1
d108 4
a111 1
 * $Log$
@
